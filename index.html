<canvas id="myCanvas" width="800" height="400" style="border:1px solid black;">
</canvas>

<script>
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");
    const imageEl = new Image();
    imageEl.src = "tileset_2.png";

    const tile_size = 8;

    // Wait for the image to load before processing
    imageEl.onload = function () {
        // Calculate the number of tiles in the tileset
        const tilesPerRow = Math.floor(imageEl.width / tile_size);
        const tilesPerColumn = Math.floor(imageEl.height / tile_size);
        const totalTiles = tilesPerRow * tilesPerColumn;
        // Create an array to store our tiles
        const tiles = [];
        let transparent_tile_added = false;

        // Extract each tile from the tileset
        for (let y = 0; y < tilesPerColumn; y++) {
            for (let x = 0; x < tilesPerRow; x++) {
                // Create a temporary canvas for each tile
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = tile_size;
                tileCanvas.height = tile_size;
                const tileCtx = tileCanvas.getContext('2d', { willReadFrequently: true, alpha: true });

                // Clear the tile canvas to ensure transparency
                tileCtx.clearRect(0, 0, tile_size, tile_size);

                // Draw the tile portion from the tileset to the temporary canvas
                tileCtx.drawImage(
                    imageEl,
                    x * tile_size, y * tile_size, tile_size, tile_size,
                    0, 0, tile_size, tile_size
                );

                // Get image data to process transparency
                const imageData = tileCtx.getImageData(0, 0, tile_size, tile_size);
                const data = imageData.data;

                let transparent_pixels = 0;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] === 0) transparent_pixels++;
                }

                if (!transparent_tile_added && transparent_pixels == tile_size * tile_size) {
                    transparent_tile_added = true;
                    space_tile = tiles.push(tileCanvas) - 1;
                }

                // Add the tile canvas to our array if it's less than 70% transparent
                if (transparent_pixels < tile_size * tile_size * 0.70) {
                    tiles.push(tileCanvas);
                }
            }
        }

        console.log(`Loaded ${tiles.length} tiles from tileset`);

        const first_border_tile = 171;
        const borders = loadBorders(tiles, first_border_tile);

        const first_letter_tile = 72;
        const letter_tiles = loadLetterTiles(tiles, first_letter_tile, space_tile);
        drawMessageBox("Hello! How are you?", 10, 10, borders, letter_tiles);
    };

    function drawTile(tile, x, y) {
        ctx.drawImage(tile, x, y, tile_size, tile_size);
    }

    function loadLetterTiles(tiles, first_letter_tile, space_tile) {
        const letters = " ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!?\":;#+%=";
        const letter_tiles = { " ": tiles[space_tile] };
        for (let i = 1; i < letters.length; i++) {
            letter_tiles[letters[i]] = tiles[first_letter_tile + i];
        }
        return letter_tiles;
    }

    function loadBorders(tiles, first_border_tile) {
        const borders = {
            "top-left": tiles[first_border_tile],
            "top": tiles[first_border_tile + 1],
            "top-right": tiles[first_border_tile + 3],
            "left": tiles[first_border_tile + 4],
            "right": tiles[first_border_tile + 5],
            "bottom-left": tiles[first_border_tile + 8],
            "bottom": tiles[first_border_tile + 9],
            "bottom-right": tiles[first_border_tile + 11],
            "fill": tiles[first_border_tile + 12]
        }
        return borders;
    }

    function drawText(text, x, y, letter_tiles) {
        for (let i = 0; i < text.length; i++) {
            drawTile(letter_tiles[text[i]], x + i * (tile_size), y);
        }
    }

    function drawBackground(borders, x, y, width, height) {
        const gradient = ctx.createLinearGradient(0, 0, 0, 100);
        gradient.addColorStop(0, "#484890"); // `rgba(100, 100, 255, 1)`);
        gradient.addColorStop(1, "#282870"); // `rgba(0, 0, 255, 1)`);
        for (let i = 1; i < width; i++) {
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width * tile_size, height * tile_size);
        }
        drawTile(borders["top-left"], x, y);
        for (let i = 1; i < width; i++) {
            drawTile(borders["top"], x + i * tile_size, y);
            drawTile(borders["bottom"], x + i * tile_size, y + height * tile_size);
        }
        drawTile(borders["top-right"], x + width * tile_size, y);
        for (let i = 1; i < height; i++) {
            drawTile(borders["left"], x, y + i * tile_size);
            drawTile(borders["right"], x + width * tile_size, y + i * tile_size);
        }
        drawTile(borders["bottom-left"], x, y + height * tile_size);
        drawTile(borders["bottom-right"], x + width * tile_size, y + height * tile_size);

    }

    function drawMessageBox(text, x, y, border_tiles, letter_tiles) {
        drawBackground(border_tiles, x, y, text.length + 2, 10);
        drawText(text, x + tile_size, y + tile_size, letter_tiles);
    }

</script>